---
title: "Adam's Analysis"
author: "Zachariah Cross & Adam Dede"
date: "2023-10-24"
output: html_document
editor_options: 
  chunk_output_type: console
---

## Load packages and set up environment

```{r message = FALSE, warning = FALSE}

knitr::opts_chunk$set(message = FALSE, warning = FALSE)

# load packages
library(tidyverse)
library(RColorBrewer)
library(hrbrthemes)
library(lme4)
# library(lmerOut)
library(lmerTest)
library(car)
library(ggeffects)
library(emmeans)
library(effects)

# set contrasts
options(contrasts=c("contr.Sum","contr.Helmert"))
options(decorate.contr.Sum="",decorate.contrasts=c("[","]"))

```

## Read in data frame

```{r load data}

# load in main data frame
df <- read.csv("R:\\MSS\\Johnson_Lab\\dtf8829\\GitHub\\HpcAccConnectivityProject\\trialLatDat_RTfix.csv", header = T)
setwd('G:\\My Drive\\Johnson\\MTL_PFC_networkFigs\\Rfigs')
# factorise variables

df$adjTime = df$peakLatHFB / df$RT

df <- df %>%
  mutate(subID= as.factor(subID),
         encRet = as.factor(encRet),
         hitMiss = as.factor(hitMiss),
         reg = as.factor(reg),
         chi = as.factor(chi)) %>% 
  filter(peakLatHFB != -1)

regLabs = unique(df$reg)
cr = regLabs[[1]]
# breakVals = seq(-500, 500, 50) ####
# for(cr in regLabs){
#   temp = filter(df, reg == cr)
#   #get hits encoding
#   cur = temp %>% filter(encRet=='Enc', hitMiss =='Hit')
#   latDif = cur$peakLatHFB - cur$peakLatLow
#   hits = lapply(seq(1,length(breakVals)-1, 1), function(x) sum(latDif>breakVals[x] & latDif<=breakVals[x+1] ) )
#   cur = temp %>% filter(encRet=='Enc', hitMiss =='Miss')
#   latDif = cur$peakLatHFB - cur$peakLatLow
#   misses = lapply(seq(1,length(breakVals)-1, 1), function(x) sum(latDif>breakVals[x] & latDif<=breakVals[x+1] ) )
#   
#   plotVals = data.frame('x' = c(breakVals[1:length(breakVals)-1] + 25, breakVals[1:length(breakVals)-1] + 25),
#                         'freq' = c(unlist(hits) / sum(unlist(hits)), unlist(misses)/ sum(unlist(misses))), 
#                         'hitMiss' = c(replicate(length(hits), 'Hits'), replicate(length(hits), 'Misses') ) ) 
#   # plotVals$hits = plotVals$hits/ sum(plotVals$hits)
#   # plotVals$misses = plotVals$misses / sum(plotVals$misses)
#   png(paste(cr, '_Encoding', '.png', sep = ''),         # File name
#     width=1024, height=768)# Color
#   print(
#     ggplot(plotVals, aes(x = x, y = freq, color = hitMiss)) + 
#     geom_line(size = 3) + 
#     theme_classic() +
#     ggtitle(paste(cr, ' Encoding')) + 
#     xlab('low first        HFB - low peak (ms))        HFB first') 
#   )
# 
#   dev.off()
# }
# 
# ggplot(df, aes(x = peakLatHFB - peakLatLow, color = hitMiss)) + 
#   geom_histogram(breaks = seq(-500,500,50), aes(y=after_stat(count) / sum(after_stat(count) ) )) + 
#                    facet_wrap(~reg)
#### section break ####


df$adjTime[df$adjTime<0] = 0
df$adjTime[df$adjTime>1] = 1

df$realID = paste(df$subID, df$chi)


# data frame for pfc
df_pfc <- df %>% 
  filter(reg == "acc" | reg == "dlPFC" | reg == "pPFC" & encRet == "Enc")

# data frame for mtl
df_mtl <- df %>% 
  filter(reg == "mtl" | reg == "hip" & encRet == "Enc")

# data frame for encoding
df_enc <- df %>% 
  filter(encRet == "Enc")

# data for our five regions
all_data <- df %>% 
  filter(reg == "mtl" | reg == "hip" | reg == "acc" | 
         reg == "dlPFC" | reg == "pPFC")

```
## reactive v. total channel counts

```{r chanCounts}


reactiveCounts = all_data %>% group_by(reg) %>% summarize(chanCount = length(unique(realID)))
reactiveCounts$Totals = c(44,247,40,79,35)

Total = sum(reactiveCounts$Totals) #total chan count
totalReact = sum(reactiveCounts$chanCount) #total reactive
propExp = totalReact / Total

reactiveCounts$exp = reactiveCounts$Totals * propExp
reactiveCounts$nonReact = reactiveCounts$Totals - reactiveCounts$chanCount

chisq.test(reactiveCounts[,c(2,5)])




```


## Get within trial timing differences one reg pair at a time

```{r within trial difs}

#don't save everything, instead just go one pair at a time and get just the 
#necessary information for making the target figure and doing the target stats

#This code generates the histograms in supplemental figure 1

regColors <- data.frame(
  parahip = rgb(214, 77, 97, maxColorValue = 255),       # dark pink 
  polarPFC = rgb(51, 102, 153, maxColorValue = 255),     # lilac
  dlPFC = rgb(145, 162, 80, maxColorValue = 255),        # light forest green
  ACC = rgb(204, 153, 204, maxColorValue = 255),         # dark red
  Hip = rgb(61, 187, 218, maxColorValue = 255)           # dusky blue
)

regions = unique(all_data$reg)
hmVals = c("Hit", "Miss")
erVals = c("Enc", "Ret")
#loop on reg 1 and reg 2 and on hit/miss and enc/ret
for(reg1 in 1:length(regions)){
  for(reg2 in 1:length(regions)){
    
    for(hm in 1:2){
      for(er in 1:2){
        
        fn <- paste( "R:\\MSS\\Johnson_Lab\\dtf8829\\publicationFigureData\\pubFigs\\" ,
                'sup1_wiTrial',regions[reg1], '_', regions[reg2],'_',
                hmVals[hm],'_', erVals[er], '.png', 
                sep = '')
        print(fn)
        # if(!file.exists(fn)){
        
        reg1Dat = all_data %>% filter(reg==regions[reg1], 
                                      hitMiss==hmVals[hm],
                                      encRet ==erVals[er])
        reg2Dat = all_data %>% filter(reg==regions[reg2], 
                                      hitMiss==hmVals[hm],
                                      encRet ==erVals[er])
        reg1Subs = unique(reg1Dat$subID)
        reg2Subs = unique(reg2Dat$subID)
        #these are the subs with simultaneous recordings:
        sharedSubs = intersect(reg1Subs, reg2Subs)
        pairDat = data.frame( 'latDif' = rep(0,1000000))
        pairi = 1
        shufi = 1
        shufDat = data.frame('latDif' = rep(0,100000000))
        
        for(ii in 1:length(sharedSubs)){
       
          reg1Cur <- reg1Dat %>% filter(subID == sharedSubs[ii])
          reg2Cur <- reg2Dat %>% filter(subID == sharedSubs[ii])
          chanVals1 = unique(reg1Cur$chi)
          chanVals2 = unique(reg2Cur$chi)
          #loop chan1 and chan2
          for(chan1 in 1:length(chanVals1)){
            for(chan2 in 1:length(chanVals2)){
              if(chanVals1[chan1] != chanVals2[chan2]){
                c1Dat <- reg1Cur %>% filter(chi == chanVals1[chan1])
                c2Dat <- reg2Cur %>% filter(chi == chanVals2[chan2])
                L = length(c1Dat$subID)
                # pairDat$lat1[pairi:(pairi+L-1)] <- c1Dat$peakLatHFB
                # pairDat$lat2[pairi:(pairi+L-1)] <- c2Dat$peakLatHFB
                # pairDat$reg1[pairi:(pairi+L-1)] <- as.character(c1Dat$reg)
                # pairDat$reg2[pairi:(pairi+L-1)] <- as.character(c2Dat$reg)
                pairDat$latDif[pairi:(pairi+L-1)] <- c1Dat$peakLatHFB - 
                                                     c2Dat$peakLatHFB
                for(si in 1:10){
                  allVals = c(c1Dat$peakLatHFB, c2Dat$peakLatHFB)
                  allVals = sample(allVals)
                
                  shufDat$latDif[shufi:(shufi+L-1)] <- allVals[1:L] - 
                                                       allVals[(L+1):(L*2)]
                  shufi = shufi+L
                }
                
                # pairDat$encRet[pairi:(pairi+L-1)] <- hmVals[hm]
                # pairDat$hitMiss[pairi:(pairi+L-1)] <- erVals[er]
                
                pairi = pairi + L
              }
            }
          }
        }
        pairDat = pairDat[1:pairi-1,]
        shufDat = shufDat[1:shufi-1,]
        binVals = rep(seq(-2500, 2500, 75), 2)
        seqL = length(binVals)/2
        plotDat = data.frame('latDif' = binVals,
                             'propVal'= length(binVals),
                             'shuf' = rep('zz', length(binVals)))
        #populate the plot data
        for(idx in 1:(length(binVals)/2-1)){
         plotDat$propVal[idx] <- sum(pairDat >= binVals[idx] & 
                                     pairDat < binVals[idx+1]) / 
                                     length(pairDat)
         plotDat$shuf[idx] = 'obs' 
         plotDat$propVal[idx+seqL] <- sum(shufDat >= binVals[idx] & 
                                     shufDat < binVals[idx+1]) / 
                                     length(shufDat)
         plotDat$shuf[idx+seqL] = 'shuf'
          
          
        }
        plotDat <- plotDat[!plotDat$shuf=='zz',]
        
        
        if(sum(pairDat>0) > sum(pairDat<0)){ #reg2
          outCol = regColors[reg2][[1]] 
        }else{
          outCol = regColors[reg1][[1]]
            
        }
        
        reg2Leads = paste(as.character(round(100*sum(pairDat>0) / 
                                         length(pairDat))), '%',
                          sep = '')
        reg1Leads = paste(as.character(round(100*sum(pairDat<0) / 
                                         length(pairDat))), '%',
                          sep = '')
         stats =  ks.test(pairDat, shufDat)
        
         outPlot <- plotDat %>% ggplot(aes(x = latDif, y = propVal, 
                                           group = shuf,
                                           linetype = shuf, linewidth = shuf,
                                           color = shuf)) + 
          geom_line() +
          xlim(c(-1500, 1500)) +
          ylim(c(0,.11)) +
          scale_linetype_manual(values = c("solid", "dashed")) +
          scale_linewidth_manual(values = c(3, 1)) +
           scale_color_manual(values = c(outCol, 'black')) + 
          geom_vline(xintercept = 0, size = 3, linetype = 'dashed') + 
          xlab(paste(regions[reg1], ' leads                      ',
                     regions[reg2], ' leads')) + 
          ggtitle(paste(erVals[er], hmVals[hm], regions[reg1], 
                          regions[reg2]))+
          theme_classic() +
                  theme(legend.position="none",
                        panel.border = element_blank(),
                        panel.grid.major = element_blank(),
                        panel.grid.minor = element_blank(),
                        axis.line = element_blank(),
                        axis.ticks.length = unit(-0.4, "cm"),
                        
                        axis.line.x = element_line(size = 2),  
                        axis.line.y = element_line(size = 2),
                        axis.ticks = element_line(size = 2),
                        axis.text.y = element_text(size = 12, face = "bold", 
                                               margin = margin(r = 10)),
                        plot.margin = margin(l = 30)  
                  ) +
          geom_text(x = -1000, y = .10, label = reg1Leads, 
                    color = 'black', size = 20) +
          geom_text(x = 1000, y = .10, label = reg2Leads, 
                    color = 'black', size = 20) #+
          # geom_text(x = -750, y = 0.01, label = paste('ks:', round(stats[[1]],2)),
          #           color = 'black', size = 15) + 
          #  geom_text(x = 450, y = 0.01, label = paste('p:', round(stats[[2]],2)),
          #            color = 'black', size = 15)
         

        
        
        png(fn,         # File name
      width=600, height=600)
      print(outPlot)
      dev.off()
        
        # }
      
        
        
        
        
        
      }
    }
  }
}



```

## Run generalised linear mixed-effects regression on full data set with adjTime as the dependent variable

```{r mixed model}

# run generalized mixed-effects model
glm_test_all_adj <- glmer(adjTime ~ hitMiss * encRet * reg + (1|realID), 
                  data = all_data, family = binomial, 
                  control = glmerControl(optimizer="bobyqa", calc.derivs = TRUE))

# get stats
summary(glm_test_all_adj)

# use emmeans contrast for post-hoc testing
em_dat_all_adj <- emmeans(glm_test_all_adj, pairwise ~ encRet* hitMiss * reg , type="response", adjust = "holm")
emm <- emmeans(glm_test_all_adj, ~ encRet * hitMiss * reg)
comp <- pairs(emm, by = c("encRet", "hitMiss"), adjust = "holm")
em_dat_all_adj
plot(em_dat_all_adj)
em_dat_all_adj = as.data.frame(em_dat_all_adj)

```
## Run generalised linear mixed-effects regression on full data set with original time as the dependent variable

```{r mixed model}

# run generalized mixed-effects model

glm_test_all_og <- lmer(peakLatHFB ~ hitMiss * encRet * reg + (1|realID), 
                  data = all_data)
# get stats
summary(glm_test_all_og)

# use emmeans contrast for post-hoc testing
em_dat_all_og <- emmeans(glm_test_all_og, pairwise ~ hitMiss * encRet | hitMiss * reg | 
                    encRet * reg, type="response", adjust = "holm")
em_dat_all_og
plot(em_dat_all_og)
em_dat_all_og = as.data.frame(em_dat_all_og)

```
## Create RT matched subsample 

```{r mixed model}

matchedSet = all_data
matchedSet$allIdx = seq(1,length(matchedSet$subID),1)
matchedSet$used = rep(0,length(matchedSet$subID))
matchedSet$trialMatch = rep(0,length(matchedSet$subID))
#figure out the area and phase with the lowest hit count
my_fun <- function(x, num_var){
  num_var <- enquo(num_var)
  
  x %>%
    summarise(avg = mean(!!num_var), n = n(),
              sd = sd(!!num_var), se = sd/sqrt(n))
}

# apply function to data frame to get averages
trialCounts <- all_data %>%
  select( encRet, reg,hitMiss, RT) %>%
  group_by( encRet, reg,hitMiss) %>%
  my_fun(RT)

# which region has the lowest count
idx = which(trialCounts$n == min(trialCounts$n))
targSet = matchedSet %>% filter(encRet == trialCounts$encRet[idx],
                                reg == trialCounts$reg[idx],
                                hitMiss == trialCounts$hitMiss[idx])
#loop over trials in the target set, and for each find the best match trial in 
#each group no repeated trials
reg_order <- c("hip", "mtl", "acc", "dlPFC", "pPFC")
hmVals = c("Hit", "Miss")
erVals = c("Enc", "Ret")
# uniqueRTs = unique(targSet$RT)
for(tt in 1:length(targSet$subID)){
  curRT = targSet$RT[tt]
  
  for(creg in reg_order){
    for(hm in hmVals){
      for(er in erVals){
        if(hm==trialCounts$hitMiss[idx] &
           er==trialCounts$encRet[idx] &
           creg==trialCounts$reg[idx] ){
          print('skip')
        } else {
          curGroup = matchedSet %>% 
                      filter(encRet == er, hitMiss == hm, reg == creg, 
                             used == 0)
          diffVals = curGroup$RT - curRT
          print(paste(tt, ':', min(abs(diffVals))))
          if(min(abs(diffVals)) < 50){
            candidates = which(abs(diffVals) ==min(abs(diffVals)))
            if(length(candidates) == 1){
              idxVal = curGroup$allIdx[candidates]
            }else{
              idxVal = curGroup$allIdx[sample(candidates,size = 1)]
            }
            matchedSet$used[idxVal] = 1
            matchedSet$trialMatch[idxVal] = tt
          }
        }
      }
    }
  }
  #check that a good match was found for all four regions
  slice = matchedSet %>% filter(trialMatch == tt)
  if(length(slice$subID)<19){
    matchedSet$used[slice$allIdx] = 0
  } else {
    matchedSet$used[targSet$allIdx[tt]] = 1
  }
  
}

testSet = matchedSet %>% filter(used==1)
trialCounts <- testSet %>%
  select( encRet, reg,hitMiss, RT) %>%
  group_by( encRet, reg,hitMiss) %>%
  my_fun(RT)


```

## Run generalised linear mixed-effects regression with RT matched subsample on adjusted time

```{r mixed model}



# run generalized mixed-effects model
glm_test_sub_adj <- glmer(adjTime ~ hitMiss * encRet * reg + (1|realID), 
                  data = testSet, family = binomial, 
                  control = glmerControl(optimizer="bobyqa", calc.derivs = TRUE))

# get stats
summary(glm_test_sub_adj)



# use emmeans contrast for post-hoc testing
em_dat_sub_adj <- emmeans(glm_test_sub_adj, pairwise ~ hitMiss * encRet | hitMiss * reg | 
                    encRet * reg, type="response", adjust = "holm")
em_dat_sub_adj
plot(em_dat_sub_adj)
em_dat_sub_adj = as.data.frame(em_dat_sub_adj)

```
## Run generalised linear mixed-effects regression with RT matched subsample on original time

```{r mixed model}



# run generalized mixed-effects model

glm_test_sub_og <- lmer(peakLatHFB ~ hitMiss * encRet * reg +  (1|realID), 
                  data = testSet)
# get stats
summary(glm_test_sub_og)

# use emmeans contrast for post-hoc testing
em_dat_sub_adj <- emmeans(glm_test_sub_og, pairwise ~ hitMiss * encRet | hitMiss * reg | 
                    encRet * reg, type="response", adjust = "holm")
em_dat_sub_adj
plot(em_dat_sub_adj)
em_dat_sub_adj = as.data.frame(em_dat_sub_adj)

```
## Generate plot to show both the predicted and raw effects with adjTime in the full dataset! 

```{r plot glmer}

#THIS IS PANEL D in Figure 1

# Color data frame in R
regColors <- data.frame(
  parahip = rgb(214, 77, 97, maxColorValue = 255),       # dark pink
  dlPFC = rgb(145, 162, 80, maxColorValue = 255),        # light forest green
  iTemp = rgb(145, 162, 80, maxColorValue = 255),        # light forest green
  lTemp = rgb(145, 162, 80, maxColorValue = 255),        # light forest green
  polarPFC = rgb(51, 102, 153, maxColorValue = 255),     # lilac
  visual = rgb(132, 125, 212, maxColorValue = 255),      # lilac
  ACC = rgb(204, 153, 204, maxColorValue = 255),         # dark red
  PCC = rgb(184, 78, 83, maxColorValue = 255),          # dark red
  Hip = rgb(61, 187, 218, maxColorValue = 255)           # dusky blue
)



# function for calculating standard error values  
my_fun <- function(x, num_var){
  num_var <- enquo(num_var)
  
  x %>%
    summarise(avg = mean(!!num_var), n = n(),
              sd = sd(!!num_var), se = sd/sqrt(n))
}

# apply function to data frame to get averages
glmer_summary <- all_data %>%
  select(subID, chi, realID, encRet, hitMiss, reg, adjTime) %>%
  group_by(subID, chi, realID, encRet, hitMiss, reg) %>%
  my_fun(adjTime) %>%
  mutate(lower = avg - se) %>%
  mutate(upper = avg + se)

# set the parameters for the jitter in the plot below
pd <- position_dodge(width = .25)
pd_2 <- position_dodge(width = .75)
jitter <- position_jitter(width = 0.1, height = 0.1)

# extract predicted model estimates
m1..eff <- Effect(c("encRet","hitMiss","reg"),glm_test_all_adj, confidence.level=.83)
m1..eff.df <- as.data.frame(m1..eff)

# re-order regions
reg_order <- c("hip", "mtl", "acc", "dlPFC", "pPFC")

# New facet label names for encoding/retrieval variable
mem.labs <- c("Encoding", "Retrieval")
names(mem.labs) <- c("Enc", "Ret")

hmVals = c("Hit", "Miss")
erVals = c("Enc", "Ret")
for(hm in 1:2){
  for(er in 1:2){
    tmpMod = filter(m1..eff.df, encRet == erVals[er], hitMiss == hmVals[hm])
    tmpPnts = filter(glmer_summary, encRet == erVals[er], hitMiss == hmVals[hm])
    
  outPlot <- ggplot(tmpMod, aes(x=hitMiss,y=fit,ymin=lower,ymax=upper)) + 
                  geom_point(aes(colour = factor(reg, level = reg_order)), 
                             position = pd_2) + 
                  geom_errorbar(aes(colour = factor(reg, level = reg_order), 
                                    ymin = lower, ymax = upper), 
                                    width = 0.6, alpha = 1, linewidth = 3, 
                                    position = pd_2) + 
                  labs(colour = "Region") +
                  scale_x_discrete(expand = c(0, 0)) +
                  scale_color_manual(values=c( regColors$Hip,
                                               regColors$parahip,
                                     regColors$ACC, 
                                     regColors$dlPFC,
                                     regColors$polarPFC),
                                     labels=reg_order) +
                  #scale_color_manual(values=c("turquoise4", "black")) +
                  ylab("Peak Latency [proportion]") +
                  ylim(c(.25, .75)) +
                  geom_hline(yintercept = c(.5), linewidth = 2, linetype = 'dashed')+
                  geom_hline(yintercept = seq(.3,.7, .05), linewidth = .75, linetype = 'dotted')+
                  geom_point(aes(hitMiss, avg, colour = factor(reg, level = reg_order)), 
                            alpha = 0.3, size = 8, data = tmpPnts, 
                            position = position_jitterdodge()) +
                  xlab("") +
                  theme_classic() +
                  theme(legend.position="none",
                        panel.border = element_blank(),
                        panel.grid.major = element_blank(),
                        panel.grid.minor = element_blank(),
                        axis.line = element_blank(),
                        axis.ticks.length = unit(-0.4, "cm"),
                        axis.ticks.x = element_blank(),
                        axis.text.x = element_blank(),
                        axis.line.x = element_line(size = 2),  
                        axis.line.y = element_line(size = 2),
                        axis.ticks = element_line(size = 2),
                        axis.text.y = element_text(size = 12, face = "bold", 
                                               margin = margin(r = 10)),
                        plot.margin = margin(l = 30)  
                  
                  )
    
  png(paste( "R:\\MSS\\Johnson_Lab\\dtf8829\\publicationFigureData\\pubFigs\\" ,
                'latencyBox','_',hmVals[hm],'_', erVals[er], '.png', 
                sep = ''),         # File name
      width=600, height=600)
  print(outPlot)
  dev.off()
  
  }
  
}

# estMeans <- as.data.frame(emmeans(glm_test, pairwise ~ hitMiss * encRet | hitMiss * reg | 
#                     encRet * reg, transform="response")) 

## Generate plot to show both the predicted and raw effects with adjTime! 

```

## Generate plot to show both the predicted and raw effects with adjTime in the subset dataset! 

```{r plot glmer}

#Figure S1, panel 1D

# Color data frame in R
regColors <- data.frame(
  parahip = rgb(214, 77, 97, maxColorValue = 255),       # dark pink
  dlPFC = rgb(145, 162, 80, maxColorValue = 255),        # light forest green
  iTemp = rgb(145, 162, 80, maxColorValue = 255),        # light forest green
  lTemp = rgb(145, 162, 80, maxColorValue = 255),        # light forest green
  polarPFC = rgb(51, 102, 153, maxColorValue = 255),     # lilac
  visual = rgb(132, 125, 212, maxColorValue = 255),      # lilac
  ACC = rgb(204, 153, 204, maxColorValue = 255),         # dark red
  PCC = rgb(184, 78, 83, maxColorValue = 255),          # dark red
  Hip = rgb(61, 187, 218, maxColorValue = 255)           # dusky blue
)



# function for calculating standard error values  
my_fun <- function(x, num_var){
  num_var <- enquo(num_var)
  
  x %>%
    summarise(avg = mean(!!num_var), n = n(),
              sd = sd(!!num_var), se = sd/sqrt(n))
}

# apply function to data frame to get averages
glmer_summary <- testSet %>%
  select(subID, chi, realID, encRet, hitMiss, reg, adjTime) %>%
  group_by(subID, chi, realID, encRet, hitMiss, reg) %>%
  my_fun(adjTime) %>%
  mutate(lower = avg - se) %>%
  mutate(upper = avg + se)

# set the parameters for the jitter in the plot below
pd <- position_dodge(width = .25)
pd_2 <- position_dodge(width = .75)
jitter <- position_jitter(width = 0.1, height = 0.1)

# extract predicted model estimates
m1..eff <- Effect(c("encRet","hitMiss","reg"),glm_test_sub_adj, confidence.level=.83)
m1..eff.df <- as.data.frame(m1..eff)

# re-order regions
reg_order <- c("hip", "mtl", "acc", "dlPFC", "pPFC")

# New facet label names for encoding/retrieval variable
mem.labs <- c("Encoding", "Retrieval")
names(mem.labs) <- c("Enc", "Ret")

hmVals = c("Hit", "Miss")
erVals = c("Enc", "Ret")
for(hm in 1:2){
  for(er in 1:2){
    tmpMod = filter(m1..eff.df, encRet == erVals[er], hitMiss == hmVals[hm])
    tmpPnts = filter(glmer_summary, encRet == erVals[er], hitMiss == hmVals[hm])
    
  outPlot <- ggplot(tmpMod, aes(x=hitMiss,y=fit,ymin=lower,ymax=upper)) + 
                  geom_point(aes(colour = factor(reg, level = reg_order)), 
                             position = pd_2) + 
                  geom_errorbar(aes(colour = factor(reg, level = reg_order), 
                                    ymin = lower, ymax = upper), 
                                    width = 0.6, alpha = 1, linewidth = 3, 
                                    position = pd_2) + 
                  labs(colour = "Region") +
                  scale_x_discrete(expand = c(0, 0)) +
                  scale_color_manual(values=c( regColors$Hip,
                                               regColors$parahip,
                                     regColors$ACC, 
                                     regColors$dlPFC,
                                     regColors$polarPFC),
                                     labels=reg_order) +
                  #scale_color_manual(values=c("turquoise4", "black")) +
                  ylab("Peak Latency [proportion]") +
                  ylim(c(.20, .75)) +
                  geom_hline(yintercept = c(.5), linewidth = 2, linetype = 'dashed')+
                  geom_hline(yintercept = seq(.3,.7, .05), linewidth = .75, linetype = 'dotted')+
                  geom_point(aes(hitMiss, avg, colour = factor(reg, level = reg_order)), 
                            alpha = 0.3, size = 8, data = tmpPnts, 
                            position = position_jitterdodge()) +
                  xlab("") +
                  theme_classic() +
                  theme(legend.position="none",
                        panel.border = element_blank(),
                        panel.grid.major = element_blank(),
                        panel.grid.minor = element_blank(),
                        axis.line = element_blank(),
                        axis.ticks.length = unit(-0.4, "cm"),
                        axis.ticks.x = element_blank(),
                        axis.text.x = element_blank(),
                        axis.line.x = element_line(size = 2),  
                        axis.line.y = element_line(size = 2),
                        axis.ticks = element_line(size = 2),
                        axis.text.y = element_text(size = 12, face = "bold", 
                                               margin = margin(r = 10)),
                        plot.margin = margin(l = 30)  
                  
                  )
    
  png(paste( "R:\\MSS\\Johnson_Lab\\dtf8829\\publicationFigureData\\pubFigs\\" ,
                'latencyBox_sub_adj_','_',hmVals[hm],'_', erVals[er], '.png', 
                sep = ''),         # File name
      width=600, height=600)
  print(outPlot)
  dev.off()
  
  }
  
}

# estMeans <- as.data.frame(emmeans(glm_test, pairwise ~ hitMiss * encRet | hitMiss * reg | 
#                     encRet * reg, transform="response")) 

## Generate plot to show both the predicted and raw effects with adjTime! 

```

## Generate plot to show both the predicted and raw effects with ORIGINAL time in the full dataset! 

```{r plot glmer}

#supplemental figure 1 panel B

# apply function to data frame to get averages
glmer_summary <- all_data %>%
  select(subID, chi, realID, encRet, hitMiss, reg, peakLatHFB) %>%
  group_by(subID, chi, realID, encRet, hitMiss, reg) %>%
  my_fun(peakLatHFB) %>%
  mutate(lower = avg - se) %>%
  mutate(upper = avg + se)

# set the parameters for the jitter in the plot below
pd <- position_dodge(width = .25)
pd_2 <- position_dodge(width = .75)
jitter <- position_jitter(width = 0.1, height = 0.1)

# extract predicted model estimates
m1..eff <- Effect(c("encRet","hitMiss","reg"),glm_test_all_og, confidence.level=.83)
m1..eff.df <- as.data.frame(m1..eff)

# re-order regions
reg_order <- c("hip", "mtl", "acc", "dlPFC", "pPFC")

# New facet label names for encoding/retrieval variable
mem.labs <- c("Encoding", "Retrieval")
names(mem.labs) <- c("Enc", "Ret")

hmVals = c("Hit", "Miss")
erVals = c("Enc", "Ret")
for(hm in 1:2){
  for(er in 1:2){
    tmpMod = filter(m1..eff.df, encRet == erVals[er], hitMiss == hmVals[hm])
    tmpPnts = filter(glmer_summary, encRet == erVals[er], hitMiss == hmVals[hm])
    
  outPlot <- ggplot(tmpMod, aes(x=hitMiss,y=fit,ymin=lower,ymax=upper)) + 
                  geom_point(aes(colour = factor(reg, level = reg_order)), 
                             position = pd_2) + 
                  geom_errorbar(aes(colour = factor(reg, level = reg_order), 
                                    ymin = lower, ymax = upper), 
                                    width = 0.6, alpha = 1, linewidth = 3, 
                                    position = pd_2) + 
                  labs(colour = "Region") +
                  scale_x_discrete(expand = c(0, 0)) +
                  scale_color_manual(values=c( regColors$Hip,
                                               regColors$parahip,
                                     regColors$ACC, 
                                     regColors$dlPFC,
                                     regColors$polarPFC),
                                     labels=reg_order) +
                  #scale_color_manual(values=c("turquoise4", "black")) +
                  ylab("Peak Latency [proportion]") +
                  ylim(c(250, 1250)) +
                  geom_hline(yintercept = c(1000), linewidth = 2, linetype = 'dashed')+
                  geom_hline(yintercept = seq(500,1500, 250), linewidth = .75, linetype = 'dotted')+
                  geom_point(aes(hitMiss, avg, colour = factor(reg, level = reg_order)), 
                            alpha = 0.3, size = 8, data = tmpPnts, 
                            position = position_jitterdodge()) +
                  xlab("") +
                  theme_classic() +
                  theme(legend.position="none",
                        panel.border = element_blank(),
                        panel.grid.major = element_blank(),
                        panel.grid.minor = element_blank(),
                        axis.line = element_blank(),
                        axis.ticks.length = unit(-0.4, "cm"),
                        axis.ticks.x = element_blank(),
                        axis.text.x = element_blank(),
                        axis.line.x = element_line(size = 2),  
                        axis.line.y = element_line(size = 2),
                        axis.ticks = element_line(size = 2),
                        axis.text.y = element_text(size = 12, face = "bold", 
                                               margin = margin(r = 10)),
                        plot.margin = margin(l = 30)  
                  
                  )
    
  png(paste( "R:\\MSS\\Johnson_Lab\\dtf8829\\publicationFigureData\\pubFigs\\" ,
                'latencyBox_ogTim_','_',hmVals[hm],'_', erVals[er], '.png', 
                sep = ''),         # File name
      width=600, height=600)
  print(outPlot)
  dev.off()
  
  }
  
}

# estMeans <- as.data.frame(emmeans(glm_test, pairwise ~ hitMiss * encRet | hitMiss * reg | 
#                     encRet * reg, transform="response")) 

## Generate plot to show both the predicted and raw effects with adjTime! 

```

## Generate plot to show both the predicted and raw effects with ORIGINAL time in the sub sample dataset! 

```{r plot glmer}

#supplemental Figure 1, panel C

# apply function to data frame to get averages
glmer_summary <- testSet %>%
  select(subID, chi, realID, encRet, hitMiss, reg, peakLatHFB) %>%
  group_by(subID, chi, realID, encRet, hitMiss, reg) %>%
  my_fun(peakLatHFB) %>%
  mutate(lower = avg - se) %>%
  mutate(upper = avg + se)

# set the parameters for the jitter in the plot below
pd <- position_dodge(width = .25)
pd_2 <- position_dodge(width = .75)
jitter <- position_jitter(width = 0.1, height = 0.1)

# extract predicted model estimates
m1..eff <- Effect(c("encRet","hitMiss","reg"),glm_test_sub_og, confidence.level=.83)
m1..eff.df <- as.data.frame(m1..eff)

# re-order regions
reg_order <- c("hip", "mtl", "acc", "dlPFC", "pPFC")

# New facet label names for encoding/retrieval variable
mem.labs <- c("Encoding", "Retrieval")
names(mem.labs) <- c("Enc", "Ret")

hmVals = c("Hit", "Miss")
erVals = c("Enc", "Ret")
for(hm in 1:2){
  for(er in 1:2){
    tmpMod = filter(m1..eff.df, encRet == erVals[er], hitMiss == hmVals[hm])
    tmpPnts = filter(glmer_summary, encRet == erVals[er], hitMiss == hmVals[hm])
    
  outPlot <- ggplot(tmpMod, aes(x=hitMiss,y=fit,ymin=lower,ymax=upper)) + 
                  geom_point(aes(colour = factor(reg, level = reg_order)), 
                             position = pd_2) + 
                  geom_errorbar(aes(colour = factor(reg, level = reg_order), 
                                    ymin = lower, ymax = upper), 
                                    width = 0.6, alpha = 1, linewidth = 3, 
                                    position = pd_2) + 
                  labs(colour = "Region") +
                  scale_x_discrete(expand = c(0, 0)) +
                  scale_color_manual(values=c( regColors$Hip,
                                               regColors$parahip,
                                     regColors$ACC, 
                                     regColors$dlPFC,
                                     regColors$polarPFC),
                                     labels=reg_order) +
                  #scale_color_manual(values=c("turquoise4", "black")) +
                  ylab("Peak Latency [proportion]") +
                  ylim(c(250, 1250)) +
                  geom_hline(yintercept = c(1000), linewidth = 2, linetype = 'dashed')+
                  geom_hline(yintercept = seq(500,1500, 250), linewidth = .75, linetype = 'dotted')+
                  geom_point(aes(hitMiss, avg, colour = factor(reg, level = reg_order)), 
                            alpha = 0.3, size = 8, data = tmpPnts, 
                            position = position_jitterdodge()) +
                  xlab("") +
                  theme_classic() +
                  theme(legend.position="none",
                        panel.border = element_blank(),
                        panel.grid.major = element_blank(),
                        panel.grid.minor = element_blank(),
                        axis.line = element_blank(),
                        axis.ticks.length = unit(-0.4, "cm"),
                        axis.ticks.x = element_blank(),
                        axis.text.x = element_blank(),
                        axis.line.x = element_line(size = 2),  
                        axis.line.y = element_line(size = 2),
                        axis.ticks = element_line(size = 2),
                        axis.text.y = element_text(size = 12, face = "bold", 
                                               margin = margin(r = 10)),
                        plot.margin = margin(l = 30)  
                  
                  )
    
  png(paste( "R:\\MSS\\Johnson_Lab\\dtf8829\\publicationFigureData\\pubFigs\\" ,
                'latencyBox_ogTim_sub_','_',hmVals[hm],'_', erVals[er], '.png', 
                sep = ''),         # File name
      width=600, height=600)
  print(outPlot)
  dev.off()
  
  }
  
}

# estMeans <- as.data.frame(emmeans(glm_test, pairwise ~ hitMiss * encRet | hitMiss * reg | 
#                     encRet * reg, transform="response")) 

## Generate plot to show both the predicted and raw effects with adjTime! 

```

## Run generalised linear mixed-effects regression on full data set with peakHFB as the dependent variable

```{r mixed model}

# run generalized mixed-effects model
glm_peak <- lmer(peakHFB ~ hitMiss * encRet * reg +(1|realID), 
                  data = all_data) 

# get stats
Anova(glm_peak)


emm <- emmeans(glm_peak, ~ encRet * hitMiss * reg)
comp <- pairs(emm, by = c("encRet", "hitMiss"), adjust = "holm")

emm <- emmeans(glm_peak, ~ encRet * hitMiss * reg)
comp <- pairs(emm, by = c("reg"), adjust = "holm")


# use emmeans contrast for post-hoc testing
em_dat_all_adj <- emmeans(glm_peak, pairwise ~ hitMiss * encRet | hitMiss * reg | 
                    encRet * reg, type="response", adjust = "holm")
em_dat_all_adj
plot(em_dat_all_adj)
em_dat_all_adj = as.data.frame(em_dat_all_adj)

```
## Generate plot to show both the predicted and raw effects with peakHFB 

```{r plot glmer}

#Figure 2 panel A 

# Color data frame in R
regColors <- data.frame(
  parahip = rgb(214, 77, 97, maxColorValue = 255),       # dark pink
  dlPFC = rgb(145, 162, 80, maxColorValue = 255),        # light forest green
  iTemp = rgb(145, 162, 80, maxColorValue = 255),        # light forest green
  lTemp = rgb(145, 162, 80, maxColorValue = 255),        # light forest green
  polarPFC = rgb(51, 102, 153, maxColorValue = 255),     # lilac
  visual = rgb(132, 125, 212, maxColorValue = 255),      # lilac
  ACC = rgb(204, 153, 204, maxColorValue = 255),         # dark red
  PCC = rgb(184, 78, 83, maxColorValue = 255),          # dark red
  Hip = rgb(61, 187, 218, maxColorValue = 255)           # dusky blue
)



# function for calculating standard error values  
my_fun <- function(x, num_var){
  num_var <- enquo(num_var)
  
  x %>%
    summarise(avg = mean(!!num_var), n = n(),
              sd = sd(!!num_var), se = sd/sqrt(n))
}

# apply function to data frame to get averages
glmer_summary <- all_data %>%
  select(subID, chi, realID, encRet, hitMiss, reg, peakHFB) %>%
  group_by(subID, chi, realID, encRet, hitMiss, reg) %>%
  my_fun(peakHFB) %>%
  mutate(lower = avg - se) %>%
  mutate(upper = avg + se)

# set the parameters for the jitter in the plot below
pd <- position_dodge(width = .25)
pd_2 <- position_dodge(width = .75)
jitter <- position_jitter(width = 0.1, height = 0.1)

# extract predicted model estimates
m1..eff <- Effect(c("encRet","hitMiss","reg"),glm_peak, confidence.level=.83)
m1..eff.df <- as.data.frame(m1..eff)

# re-order regions
reg_order <- c("hip", "mtl", "acc", "dlPFC", "pPFC")

# New facet label names for encoding/retrieval variable
mem.labs <- c("Encoding", "Retrieval")
names(mem.labs) <- c("Enc", "Ret")

hmVals = c("Hit", "Miss")
erVals = c("Enc", "Ret")
for(hm in 1:2){
  for(er in 1:2){
    tmpMod = filter(m1..eff.df, encRet == erVals[er], hitMiss == hmVals[hm])
    tmpPnts = filter(glmer_summary, encRet == erVals[er], hitMiss == hmVals[hm])
    
  outPlot <- ggplot(tmpMod, aes(x=hitMiss,y=fit,ymin=lower,ymax=upper)) + 
                  geom_point(aes(colour = factor(reg, level = reg_order)), 
                             position = pd_2) + 
                  geom_errorbar(aes(colour = factor(reg, level = reg_order), 
                                    ymin = lower, ymax = upper), 
                                    width = 0.6, alpha = 1, linewidth = 3, 
                                    position = pd_2) + 
                  labs(colour = "Region") +
                  scale_x_discrete(expand = c(0, 0)) +
                  scale_color_manual(values=c( regColors$Hip,
                                               regColors$parahip,
                                     regColors$ACC, 
                                     regColors$dlPFC,
                                     regColors$polarPFC),
                                     labels=reg_order) +
                  #scale_color_manual(values=c("turquoise4", "black")) +
                  ylab("Peak HFB [z-score]") +
                  ylim(c(0, 70)) +
                  # geom_hline(yintercept = c(15), linewidth = 2, linetype = 'dashed')+
                  geom_hline(yintercept = seq(10,60, 10), linewidth = .75, linetype = 'dotted')+
                  geom_point(aes(hitMiss, avg, colour = factor(reg, level = reg_order)), 
                            alpha = 0.3, size = 8, data = tmpPnts, 
                            position = position_jitterdodge()) +
                  xlab("") +
                  theme_classic() +
                  theme(legend.position="none",
                        panel.border = element_blank(),
                        panel.grid.major = element_blank(),
                        panel.grid.minor = element_blank(),
                        axis.line = element_blank(),
                        axis.ticks.length = unit(-0.4, "cm"),
                        axis.ticks.x = element_blank(),
                        axis.text.x = element_blank(),
                        axis.line.x = element_line(size = 2),  
                        axis.line.y = element_line(size = 2),
                        axis.ticks = element_line(size = 2),
                        axis.text.y = element_text(size = 12, face = "bold", 
                                               margin = margin(r = 10)),
                        plot.margin = margin(l = 30)  
                  
                  )
    
  png(paste( "R:\\MSS\\Johnson_Lab\\dtf8829\\publicationFigureData\\pubFigs\\" ,
                'Fig2_HFBpeak','_',hmVals[hm],'_', erVals[er], '.png', 
                sep = ''),         # File name
      width=600, height=600)
  print(outPlot)
  dev.off()
  
  }
  
}

# estMeans <- as.data.frame(emmeans(glm_test, pairwise ~ hitMiss * encRet | hitMiss * reg | 
#                     encRet * reg, transform="response")) 

## Generate plot to show both the predicted and raw effects with adjTime! 

```

## scratch plot stuff

```{r plot glmer}


#I'm going to make difference plots for hit - miss difference within each phase
hmVals = c("Hit", "Miss")
erVals = c("Enc", "Ret")
  for(er in 1:2){
    targContrast = paste("Hit ", erVals[er], ' - ', "Miss ", erVals[er], 
                         sep = '')
    tmpMod = filter(em_dat, contrast == targContrast)
    tmpPnts = filter(glmer_summary, encRet == erVals[er])
    
    # negative values mean that hit is before miss
    diff_df <- aggregate(avg ~ realID, tmpPnts, function(x) -diff(x)[1])
    metaDat = tmpPnts %>% filter(hitMiss == "Hit")
    tmpPnts = merge(metaDat, diff_df, by = "realID", all.x = FALSE)
    
    tmpMod <- aggregate(avg.y ~ reg, tmpPnts, function(x) mean(x))
    tmpModSE <- aggregate(avg.y ~ reg, tmpPnts, 
                          function(x) sd(x) / sqrt(length(x)))
    tmpMod = merge(tmpMod, tmpModSE, by = "reg")
    tmpMod$emmean = tmpMod$avg.y.x
    tmpMod$SE = tmpMod$avg.y.y
    
    
    tmpMod$lower = tmpMod$emmean - tmpMod$SE
    tmpMod$upper = tmpMod$emmean + tmpMod$SE
    tmpMod$hitMiss = "Hit"
    
    
  outPlot <- ggplot(tmpMod, aes(x=hitMiss,y=emmean,ymin=lower,ymax=upper)) + 
                  geom_point(aes(colour = factor(reg, level = reg_order)), 
                             position = pd_2) + 
                  geom_errorbar(aes(colour = factor(reg, level = reg_order), 
                                    ymin = lower, ymax = upper), 
                                    width = 0.6, alpha = 1, linewidth = 3, 
                                    position = pd_2) + 
                  labs(colour = "Region") +
                  scale_x_discrete(expand = c(0, 0)) +
                  scale_color_manual(values=c( regColors$Hip,
                                               regColors$parahip,
                                     regColors$ACC, 
                                     regColors$dlPFC,
                                     regColors$polarPFC),
                                     labels=reg_order) +
                  geom_hline(yintercept = 0, linetype = "dashed", 
                             color = "black", size = 2) +
                  #scale_color_manual(values=c("turquoise4", "black")) +
                  ylab("Peak Latency [proportion]") +
                  ylim(c(-500, 500)) +
                  geom_point(aes(hitMiss, avg.y, colour = factor(reg, level = reg_order)), 
                            alpha = 0.3, size = 5, data = tmpPnts, 
                            position = position_jitterdodge()) +
                  xlab("") +
                  theme_classic() +
                  theme(legend.position="none",
                        panel.border = element_blank(),
                        panel.grid.major = element_blank(),
                        panel.grid.minor = element_blank(),
                        axis.line = element_blank(),
                        axis.ticks.length = unit(-0.4, "cm"),
                        axis.ticks.x = element_blank(),
                        axis.text.x = element_blank(),
                        axis.line.x = element_line(size = 2),  
                        axis.line.y = element_line(size = 2),
                        axis.ticks = element_line(size = 2),
                        axis.text.y = element_text(size = 12, face = "bold", 
                                               margin = margin(r = 10)),
                        plot.margin = margin(l = 30)  
                  
                  )
    
  png(paste( "R:\\MSS\\Johnson_Lab\\dtf8829\\publicationFigureData\\pubFigs\\" ,
                'latencyBox','_','hmDif','_', erVals[er], '.png', 
                sep = ''),         # File name
      width=600, height=600)
  print(outPlot)
  dev.off()
  
  }

#plots for the enc - ret difference wtihin hits and within misses
hmVals = c("Hit", "Miss")
erVals = c("Enc", "Ret")
  for(hm in 1:2){
        targContrast = paste(hmVals[hm],  ' Enc', ' - ', hmVals[hm], ' Ret', 
                         sep = '')
    tmpMod = filter(em_dat, contrast == targContrast)
    tmpPnts = filter(glmer_summary, hitMiss == hmVals[hm])
    
    # negative values mean that hit is before miss
    diff_df <- aggregate(avg ~ realID, tmpPnts, function(x) -diff(x)[1])
    metaDat = tmpPnts %>% filter(hitMiss == hmVals[hm])
    tmpPnts = merge(metaDat, diff_df, by = "realID", all.x = FALSE)
    
    tmpMod <- aggregate(avg.y ~ reg, tmpPnts, function(x) mean(x))
    tmpModSE <- aggregate(avg.y ~ reg, tmpPnts, 
                          function(x) sd(x) / sqrt(length(x)))
    tmpMod = merge(tmpMod, tmpModSE, by = "reg")
    tmpMod$emmean = tmpMod$avg.y.x
    tmpMod$SE = tmpMod$avg.y.y
    
    
    tmpMod$lower = tmpMod$emmean - tmpMod$SE
    tmpMod$upper = tmpMod$emmean + tmpMod$SE
    tmpMod$hitMiss =  hmVals[hm]
    
    
  outPlot <- ggplot(tmpMod, aes(x=hitMiss,y=emmean,ymin=lower,ymax=upper)) + 
                  geom_point(aes(colour = factor(reg, level = reg_order)), 
                             position = pd_2) + 
                  geom_errorbar(aes(colour = factor(reg, level = reg_order), 
                                    ymin = lower, ymax = upper), 
                                    width = 0.6, alpha = 1, linewidth = 3, 
                                    position = pd_2) + 
                  labs(colour = "Region") +
                  scale_x_discrete(expand = c(0, 0)) +
                  scale_color_manual(values=c( regColors$Hip,
                                               regColors$parahip,
                                     regColors$ACC, 
                                     regColors$dlPFC,
                                     regColors$polarPFC),
                                     labels=reg_order) +
                  geom_hline(yintercept = 0, linetype = "dashed", 
                             color = "black", size = 2) +
                  #scale_color_manual(values=c("turquoise4", "black")) +
                  ylab("Peak Latency [proportion]") +
                  ylim(c(-500, 500)) +
                  geom_point(aes(hitMiss, avg.y, colour = factor(reg, level = reg_order)), 
                            alpha = 0.3, size = 5, data = tmpPnts, 
                            position = position_jitterdodge()) +
                  xlab("") +
                  theme_classic() +
                  theme(legend.position="none",
                        panel.border = element_blank(),
                        panel.grid.major = element_blank(),
                        panel.grid.minor = element_blank(),
                        axis.line = element_blank(),
                        axis.ticks.length = unit(-0.4, "cm"),
                        axis.ticks.x = element_blank(),
                        axis.text.x = element_blank(),
                        axis.line.x = element_line(size = 2),  
                        axis.line.y = element_line(size = 2),
                        axis.ticks = element_line(size = 2),
                        axis.text.y = element_text(size = 12, face = "bold", 
                                               margin = margin(r = 10)),
                        plot.margin = margin(l = 30)  
                  
                  )
    
  png(paste( "R:\\MSS\\Johnson_Lab\\dtf8829\\publicationFigureData\\pubFigs\\" ,
                'latencyBox','_','erDif','_', hmVals[hm], '.png', 
                sep = ''),         # File name
      width=600, height=600)
  print(outPlot)
  dev.off()
  
  }




# plot the modeled effects with raw data
ggplot(m1..eff.df, aes(x=hitMiss,y=fit,ymin=lower,ymax=upper)) + 
  geom_point(aes(colour = factor(reg, level = reg_order)), position = pd_2) + 
  geom_errorbar(aes(colour = factor(reg, level = reg_order), ymin = lower, 
                    ymax = upper), width = 0.6, alpha = 1, linewidth = 3, 
                position = pd_2) + 
  labs(colour = "Region") +
  scale_color_manual(values=c( regColors$parahip, 
                               regColors$Hip,
                               regColors$dlPFC,
                               regColors$ACC,
                               regColors$polarPFC),
                         labels=reg_order) +
  #scale_color_manual(values=c("turquoise4", "black")) +
  ylab("Peak Latency [proportion]") +
  ylim(c(0.25, 0.75)) +
  geom_point(aes(hitMiss, avg, colour = factor(reg, level = reg_order)), 
             alpha = 0.3, size = 2, data = glmer_summary, position = position_jitterdodge()) +
  xlab("") +
  theme_light() +
  theme(legend.position="right",
        legend.text = element_text(size = 10, colour = "black"),
        legend.title = element_text(size = 12, colour = "black"),
        panel.border = element_rect(color="black", fill=NA, size = 1), 
        strip.background = element_rect(fill="gray", color="black"), 
        strip.text.x = element_text(size = 12, colour = "black"),
        strip.text.y = element_text(size = 12, colour = "black"),
        axis.text = element_text(size = 12),
        plot.title = element_text(size = 16, face = "bold"),
        axis.title = element_text(size = 16)) +
  facet_grid(~encRet, labeller = labeller(encRet = mem.labs))

```



## Generate plot to show both the predicted and raw effects

```{r plot glmer}


# Color data frame in R
regColors <- data.frame(
  parahip = rgb(214, 77, 97, maxColorValue = 255),       # dark pink
  dlPFC = rgb(145, 162, 80, maxColorValue = 255),        # light forest green
  iTemp = rgb(145, 162, 80, maxColorValue = 255),        # light forest green
  lTemp = rgb(145, 162, 80, maxColorValue = 255),        # light forest green
  polarPFC = rgb(51, 102, 153, maxColorValue = 255),     # lilac
  visual = rgb(132, 125, 212, maxColorValue = 255),      # lilac
  ACC = rgb(204, 153, 204, maxColorValue = 255),         # dark red
  PCC = rgb(184, 78, 83, maxColorValue = 255),          # dark red
  Hip = rgb(61, 187, 218, maxColorValue = 255)           # dusky blue
)



# function for calculating standard error values  
my_fun <- function(x, num_var){
  num_var <- enquo(num_var)
  
  x %>%
    summarise(avg = mean(!!num_var), n = n(),
              sd = sd(!!num_var), se = sd/sqrt(n))
}

# apply function to data frame to get averages
glmer_summary <- all_data %>%
  select(subID, chi, realID, encRet, hitMiss, reg, adjTime) %>%
  group_by(subID, chi, realID, encRet, hitMiss, reg) %>%
  my_fun(adjTime) %>%
  mutate(lower = avg - se) %>%
  mutate(upper = avg + se)

# set the parameters for the jitter in the plot below
pd <- position_dodge(width = .25)
pd_2 <- position_dodge(width = .75)
jitter <- position_jitter(width = 0.1, height = 0.1)

# extract predicted model estimates
m1..eff <- Effect(c("encRet","hitMiss","reg"),glm_test, confidence.level=.83)
m1..eff.df <- as.data.frame(m1..eff)

# re-order regions
reg_order <- c("hip", "mtl", "acc", "dlPFC", "pPFC")

# New facet label names for encoding/retrieval variable
mem.labs <- c("Encoding", "Retrieval")
names(mem.labs) <- c("Enc", "Ret")

hmVals = c("Hit", "Miss")
erVals = c("Enc", "Ret")
for(hm in 1:2){
  for(er in 1:2){
    tmpMod = filter(m1..eff.df, encRet == erVals[er], hitMiss == hmVals[hm])
    tmpPnts = filter(glmer_summary, encRet == erVals[er], hitMiss == hmVals[hm])
    
  outPlot <- ggplot(tmpMod, aes(x=hitMiss,y=fit,ymin=lower,ymax=upper)) + 
                  geom_point(aes(colour = factor(reg, level = reg_order)), 
                             position = pd_2) + 
                  geom_errorbar(aes(colour = factor(reg, level = reg_order), 
                                    ymin = lower, ymax = upper), 
                                    width = 0.6, alpha = 1, linewidth = 3, 
                                    position = pd_2) + 
                  labs(colour = "Region") +
                  scale_x_discrete(expand = c(0, 0)) +
                  scale_color_manual(values=c( regColors$Hip,
                                               regColors$parahip,
                                     regColors$ACC, 
                                     regColors$dlPFC,
                                     regColors$polarPFC),
                                     labels=reg_order) +
                  #scale_color_manual(values=c("turquoise4", "black")) +
                  ylab("Peak Latency [proportion]") +
                  ylim(c(0.25, 0.75)) +
                  geom_point(aes(hitMiss, avg, colour = factor(reg, level = reg_order)), 
                            alpha = 0.3, size = 8, data = tmpPnts, 
                            position = position_jitterdodge()) +
                  xlab("") +
                  theme_classic() +
                  theme(legend.position="none",
                        panel.border = element_blank(),
                        panel.grid.major = element_blank(),
                        panel.grid.minor = element_blank(),
                        axis.line = element_blank(),
                        axis.ticks.length = unit(-0.4, "cm"),
                        axis.ticks.x = element_blank(),
                        axis.text.x = element_blank(),
                        axis.line.x = element_line(size = 2),  
                        axis.line.y = element_line(size = 2),
                        axis.ticks = element_line(size = 2),
                        axis.text.y = element_text(size = 12, face = "bold", 
                                               margin = margin(r = 10)),
                        plot.margin = margin(l = 30)  
                  
                  )
    
  png(paste( "R:\\MSS\\Johnson_Lab\\dtf8829\\publicationFigureData\\pubFigs\\" ,
                'latencyBox','_',hmVals[hm],'_', erVals[er], '.png', 
                sep = ''),         # File name
      width=600, height=600)
  print(outPlot)
  dev.off()
  
  }
  
}

estMeans <- as.data.frame(emmeans(glm_test, pairwise ~ hitMiss * encRet | hitMiss * reg | 
                    encRet * reg, transform="response")) 

#I'm going to make difference plots for hit - miss difference within each phase
hmVals = c("Hit", "Miss")
erVals = c("Enc", "Ret")
  for(er in 1:2){
    targContrast = paste("Hit ", erVals[er], ' - ', "Miss ", erVals[er], 
                         sep = '')
    tmpMod = filter(estMeans, contrast == targContrast)
    tmpPnts = filter(glmer_summary, encRet == erVals[er])
    
    # negative values mean that hit is before miss
    diff_df <- aggregate(avg ~ realID, tmpPnts, function(x) -diff(x)[1])
    metaDat = tmpPnts %>% filter(hitMiss == "Hit")
    tmpPnts = merge(metaDat, diff_df, by = "realID", all.x = FALSE)
    
    tmpMod <- aggregate(avg.y ~ reg, tmpPnts, function(x) mean(x))
    tmpModSE <- aggregate(avg.y ~ reg, tmpPnts, 
                          function(x) sd(x) / sqrt(length(x)))
    tmpMod = merge(tmpMod, tmpModSE, by = "reg")
    tmpMod$emmean = tmpMod$avg.y.x
    tmpMod$SE = tmpMod$avg.y.y
    
    
    tmpMod$lower = tmpMod$emmean - tmpMod$SE
    tmpMod$upper = tmpMod$emmean + tmpMod$SE
    tmpMod$hitMiss = "Hit"
    
    
  outPlot <- ggplot(tmpMod, aes(x=hitMiss,y=emmean,ymin=lower,ymax=upper)) + 
                  geom_point(aes(colour = factor(reg, level = reg_order)), 
                             position = pd_2) + 
                  geom_errorbar(aes(colour = factor(reg, level = reg_order), 
                                    ymin = lower, ymax = upper), 
                                    width = 0.6, alpha = 1, linewidth = 3, 
                                    position = pd_2) + 
                  labs(colour = "Region") +
                  scale_x_discrete(expand = c(0, 0)) +
                  scale_color_manual(values=c( regColors$Hip,
                                               regColors$parahip,
                                     regColors$ACC, 
                                     regColors$dlPFC,
                                     regColors$polarPFC),
                                     labels=reg_order) +
                  geom_hline(yintercept = 0, linetype = "dashed", 
                             color = "black", size = 2) +
                  #scale_color_manual(values=c("turquoise4", "black")) +
                  ylab("Peak Latency [proportion]") +
                  ylim(c(-.25, 0.25)) +
                  geom_point(aes(hitMiss, avg.y, colour = factor(reg, level = reg_order)), 
                            alpha = 0.3, size = 5, data = tmpPnts, 
                            position = position_jitterdodge()) +
                  xlab("") +
                  theme_classic() +
                  theme(legend.position="none",
                        panel.border = element_blank(),
                        panel.grid.major = element_blank(),
                        panel.grid.minor = element_blank(),
                        axis.line = element_blank(),
                        axis.ticks.length = unit(-0.4, "cm"),
                        axis.ticks.x = element_blank(),
                        axis.text.x = element_blank(),
                        axis.line.x = element_line(size = 2),  
                        axis.line.y = element_line(size = 2),
                        axis.ticks = element_line(size = 2),
                        axis.text.y = element_text(size = 12, face = "bold", 
                                               margin = margin(r = 10)),
                        plot.margin = margin(l = 30)  
                  
                  )
    
  png(paste( "R:\\MSS\\Johnson_Lab\\dtf8829\\publicationFigureData\\pubFigs\\" ,
                'latencyBox','_','hmDif','_', erVals[er], '.png', 
                sep = ''),         # File name
      width=600, height=600)
  print(outPlot)
  dev.off()
  
  }

#plots for the enc - ret difference wtihin hits and within misses
hmVals = c("Hit", "Miss")
erVals = c("Enc", "Ret")
  for(hm in 1:2){
        targContrast = paste(hmVals[hm],  ' Enc', ' - ', hmVals[hm], ' Ret', 
                         sep = '')
    tmpMod = filter(estMeans, contrast == targContrast)
    tmpPnts = filter(glmer_summary, hitMiss == hmVals[hm])
    
    # negative values mean that hit is before miss
    diff_df <- aggregate(avg ~ realID, tmpPnts, function(x) -diff(x)[1])
    metaDat = tmpPnts %>% filter(hitMiss == hmVals[hm])
    tmpPnts = merge(metaDat, diff_df, by = "realID", all.x = FALSE)
    
    tmpMod <- aggregate(avg.y ~ reg, tmpPnts, function(x) mean(x))
    tmpModSE <- aggregate(avg.y ~ reg, tmpPnts, 
                          function(x) sd(x) / sqrt(length(x)))
    tmpMod = merge(tmpMod, tmpModSE, by = "reg")
    tmpMod$emmean = tmpMod$avg.y.x
    tmpMod$SE = tmpMod$avg.y.y
    
    
    tmpMod$lower = tmpMod$emmean - tmpMod$SE
    tmpMod$upper = tmpMod$emmean + tmpMod$SE
    tmpMod$hitMiss =  hmVals[hm]
    
    
  outPlot <- ggplot(tmpMod, aes(x=hitMiss,y=emmean,ymin=lower,ymax=upper)) + 
                  geom_point(aes(colour = factor(reg, level = reg_order)), 
                             position = pd_2) + 
                  geom_errorbar(aes(colour = factor(reg, level = reg_order), 
                                    ymin = lower, ymax = upper), 
                                    width = 0.6, alpha = 1, linewidth = 3, 
                                    position = pd_2) + 
                  labs(colour = "Region") +
                  scale_x_discrete(expand = c(0, 0)) +
                  scale_color_manual(values=c( regColors$Hip,
                                               regColors$parahip,
                                     regColors$ACC, 
                                     regColors$dlPFC,
                                     regColors$polarPFC),
                                     labels=reg_order) +
                  geom_hline(yintercept = 0, linetype = "dashed", 
                             color = "black", size = 2) +
                  #scale_color_manual(values=c("turquoise4", "black")) +
                  ylab("Peak Latency [proportion]") +
                  ylim(c(-.25, 0.25)) +
                  geom_point(aes(hitMiss, avg.y, colour = factor(reg, level = reg_order)), 
                            alpha = 0.3, size = 5, data = tmpPnts, 
                            position = position_jitterdodge()) +
                  xlab("") +
                  theme_classic() +
                  theme(legend.position="none",
                        panel.border = element_blank(),
                        panel.grid.major = element_blank(),
                        panel.grid.minor = element_blank(),
                        axis.line = element_blank(),
                        axis.ticks.length = unit(-0.4, "cm"),
                        axis.ticks.x = element_blank(),
                        axis.text.x = element_blank(),
                        axis.line.x = element_line(size = 2),  
                        axis.line.y = element_line(size = 2),
                        axis.ticks = element_line(size = 2),
                        axis.text.y = element_text(size = 12, face = "bold", 
                                               margin = margin(r = 10)),
                        plot.margin = margin(l = 30)  
                  
                  )
    
  png(paste( "R:\\MSS\\Johnson_Lab\\dtf8829\\publicationFigureData\\pubFigs\\" ,
                'latencyBox','_','erDif','_', hmVals[hm], '.png', 
                sep = ''),         # File name
      width=600, height=600)
  print(outPlot)
  dev.off()
  
  }




# plot the modeled effects with raw data
ggplot(m1..eff.df, aes(x=hitMiss,y=fit,ymin=lower,ymax=upper)) + 
  geom_point(aes(colour = factor(reg, level = reg_order)), position = pd_2) + 
  geom_errorbar(aes(colour = factor(reg, level = reg_order), ymin = lower, 
                    ymax = upper), width = 0.6, alpha = 1, linewidth = 3, 
                position = pd_2) + 
  labs(colour = "Region") +
  scale_color_manual(values=c( regColors$parahip, 
                               regColors$Hip,
                               regColors$dlPFC,
                               regColors$ACC,
                               regColors$polarPFC),
                         labels=reg_order) +
  #scale_color_manual(values=c("turquoise4", "black")) +
  ylab("Peak Latency [proportion]") +
  ylim(c(0.25, 0.75)) +
  geom_point(aes(hitMiss, avg, colour = factor(reg, level = reg_order)), 
             alpha = 0.3, size = 2, data = glmer_summary, position = position_jitterdodge()) +
  xlab("") +
  theme_light() +
  theme(legend.position="right",
        legend.text = element_text(size = 10, colour = "black"),
        legend.title = element_text(size = 12, colour = "black"),
        panel.border = element_rect(color="black", fill=NA, size = 1), 
        strip.background = element_rect(fill="gray", color="black"), 
        strip.text.x = element_text(size = 12, colour = "black"),
        strip.text.y = element_text(size = 12, colour = "black"),
        axis.text = element_text(size = 12),
        plot.title = element_text(size = 16, face = "bold"),
        axis.title = element_text(size = 16)) +
  facet_grid(~encRet, labeller = labeller(encRet = mem.labs))

```


## Get session information

```{r session info}
# session info
pander::pander(sessionInfo(), compact = FALSE)
```
